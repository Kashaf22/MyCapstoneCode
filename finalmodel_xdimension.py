# -*- coding: utf-8 -*-
"""FinalModel_XDimension.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JDvSi0gsN2bnb6f17NZ8kLGOOPHOd0Cv
"""

import numpy as np
import json
from keras.models import Sequential
from keras.layers import LSTM, Dense
from keras.regularizers import l2
import os

# Specify the directory and file pattern if needed
data_directory = '/content/sample_data'
file_names = ['realistic_trajectory_data-3.json', 'realistic_trajectory_data-4.json', 'realistic_trajectory_data-5.json', 'realistic_trajectory_data-6.json', 'realistic_trajectory_data-7.json', 'realistic_trajectory_data-8.json', 'realistic_trajectory_data-9.json', 'realistic_trajectory_data-10.json', 'realistic_trajectory_data-11.json', 'realistic_trajectory_data-12.json', 'realistic_trajectory_data-13.json', 'realistic_trajectory_data-14.json', 'realistic_trajectory_data-15.json', 'realistic_trajectory_data-16.json', ]  # Add all your file names here

# Initialize lists to store combined data
trajectories = []
initial_accs = []
in_goal = []

# Load and combine data from all files
for file_name in file_names:
    file_path = os.path.join(data_directory, file_name)
    with open(file_path, 'r') as file:
        data = json.load(file)
        trajectories.extend([[point['x']] for point in data])
        initial_accs.extend([[point['ax']] for point in data])
        in_goal.extend([1 if point['in_goal'] else 0 for point in data])

# Parameters
num_timesteps = 13  # Number of timesteps per sequence

# Prepare the training data
X_train_pos = []
X_train_acc = []
y_train = []
y_train_goal = []

for i in range(len(trajectories) - num_timesteps):
    X_train_pos.append(trajectories[i:i+num_timesteps])
    X_train_acc.append(initial_accs[i])
    y_train.append(trajectories[i + num_timesteps])
    y_train_goal.append(in_goal[i + num_timesteps])

X_train_pos = np.array(X_train_pos)
X_train_acc = np.array(X_train_acc)
y_train = np.array(y_train)
y_train_goal = np.array(y_train_goal)

from keras.layers import Dense, LSTM, Dropout, Input, Concatenate, Reshape
from keras.models import Model
from keras.regularizers import l2

# Define the LSTM model
input_pos = Input(shape=(num_timesteps, 1))  # Only 1 feature per timestep (x position)
input_acc = Input(shape=(1,))  # Only 1 feature for acceleration (ax), reshaped later

# LSTM layers for trajectory
x = LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01))(input_pos)
x = Dropout(0.2)(x)
x = LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01))(x)
x = Dropout(0.2)(x)
x = LSTM(64, kernel_regularizer=l2(0.01))(x)

# Reshape acceleration input to match the dimensions needed for Concatenate
reshaped_acc = Reshape((1,))(input_acc)
combined = Concatenate(axis=-1)([x, reshaped_acc])

# Output layers
output_pos = Dense(1, activation='linear', name='position')(combined)  # Predicts x position
output_goal = Dense(1, activation='sigmoid', name='goal')(combined)  # Predicts goal status

model = Model(inputs=[input_pos, input_acc], outputs=[output_pos, output_goal])

# Compile the model
model.compile(optimizer='adam', loss={'position': 'mean_squared_error', 'goal': 'binary_crossentropy'},
              loss_weights={'position': 1.0, 'goal': 0.1})

# Train the model
model.fit([X_train_pos, X_train_acc], [y_train, y_train_goal], epochs=200, batch_size=64, validation_split=0.2)

# Save the model
model.save('x_position_goal_model.keras')

import numpy as np
from keras.models import load_model

# Load the previously saved model
model = load_model('/content/sample_data/x_position_goal_model.keras')

# Function to generate predictions recursively
def generate_predictions(initial_position, initial_acceleration, num_timesteps, num_predictions):
    # Start with the initial position repeated to fill the time steps
    current_position = np.full((num_timesteps, 1), initial_position)  # Shape (num_timesteps, 1)
    initial_acceleration = np.array([initial_acceleration])  # Shape (1,)

    predictions = []

    for _ in range(num_predictions):
        # Prepare inputs for prediction
        input_position = current_position.reshape(1, num_timesteps, 1)  # Reshape for LSTM input
        input_acceleration = initial_acceleration.reshape(1, 1)  # Reshape for LSTM input

        # Predict the next position
        predicted_position = model.predict([input_position, input_acceleration])

        # Check the type of predicted_position and ensure it's an np.array
        if isinstance(predicted_position, list):
            predicted_position = np.array(predicted_position[0])  # Assuming the list contains one array
        else:
            predicted_position = np.array(predicted_position)

        # Append the predicted position to the output
        predictions.append(predicted_position.flatten().tolist())

        # Update the current position sequence
        current_position = np.vstack((current_position[1:], predicted_position))

    return predictions

# Example usage:
initial_position = 3.9386787747618235 # Starting x position
initial_acceleration = 574.583727141724  # Starting ax value, assuming constant acceleration
num_timesteps = 13
num_predictions = 15

# Generate predictions
predicted_positions = generate_predictions(initial_position, initial_acceleration, num_timesteps, num_predictions)

# Print the predicted positions
for i, position in enumerate(predicted_positions, 1):
    print(f"Predicted position {i}: x = {position}")

"""Compare Trajectory 1 for Predicted Vs Actual Data"""

import matplotlib.pyplot as plt
import numpy as np

# Actual x positions
actual_x_positions = np.array([0.0, 1.3084617266825491, 2.6169234533650982, 3.925385180047647,
                               5.2338469067301965, 6.542308633412746, 7.850770360095294,
                               9.159232086777843, 10.467693813460393, 11.776155540142941])

# Predicted x positions
predicted_x_positions = np.array([5.70370388, 7.50136995, 8.51977062, 9.04247284, 9.28615952,
                                  9.35622406, 9.25539207, 9.1537838, 9.37049103, 10.44326782,
                                  2.55371881, 6.25788736, 13.39840794, 19.34666634, 26.75013542])

# Create the plot
plt.figure(figsize=(10, 5))
plt.plot(actual_x_positions, 'o-', label='Actual x Positions', color='blue')
plt.plot(predicted_x_positions, 'x-', label='Predicted x Positions', color='red')

# Highlight the goal post area using vertical lines at the indices where x = 11 to x = 14 fall
# Assuming indices match the closest actual x values around 11 and 14
goal_start_index = np.abs(actual_x_positions - 11).argmin()
goal_end_index = np.abs(actual_x_positions - 14).argmin()
plt.axvline(goal_start_index, color='green', linestyle='--', label='Goal Post Start (x=11)')
plt.axvline(goal_end_index, color='green', linestyle='--', label='Goal Post End (x=14)')
plt.fill_betweenx(y=[min(actual_x_positions.min(), predicted_x_positions.min()),
                     max(actual_x_positions.max(), predicted_x_positions.max())],
                 x1=goal_start_index, x2=goal_end_index, color='green', alpha=0.1)

# Adding labels and legend
plt.xlabel('Index (Sequence in Dataset)')
plt.ylabel('X Position')
plt.title('Comparison of Actual and Predicted X Positions with Goal Posts')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

"""Compare Trajectory 2 for Predicted Vs Actual Data"""

import matplotlib.pyplot as plt

# Data for the trajectory (actual data)
trajectory_data = [
    {"time": 0.0, "x": 0.0, "y": 0.0},
    {"time": 0.10204081632653061, "x": 2.6025668555657986, "y": 0.3962569241765349},
    {"time": 0.20408163265306123, "x": 5.205133711131597, "y": 0.7925138483530698},
    {"time": 0.30612244897959184, "x": 7.807700566697396, "y": 1.1887707725296046},
    {"time": 0.40816326530612246, "x": 10.410267422263194, "y": 1.5850276967061396},
    {"time": 0.5102040816326531, "x": 13.012834277828993, "y": 1.9812846208826744},
    {"time": 0.6122448979591837, "x": 13.012834277828993, "y": 1.9812846208826744},
    {"time": 3.8775510204081636, "x": 13.012834277828993, "y": 1.9812846208826744}
]

# Predicted trajectory data (please replace these placeholders with your actual data)
predicted_x_positions = [5.743730068206787, 13.114158630371094, 21.508548736572266, 29.83004379272461, 37.901973724365234]
predicted_y_positions = [3.055102825164795, 4.994770526885986, 8.398904800415039, 13.468563079833984, 18.455608367919922]

# Extract x and y coordinates from actual data
x_actual = [point['x'] for point in trajectory_data]
y_actual = [point['y'] for point in trajectory_data]

# Create a plot
fig, ax = plt.subplots()

# Plotting the actual trajectory
ax.plot(x_actual, y_actual, label='Actual Trajectory', marker='o', linestyle='-', color='blue')

# Plotting the predicted trajectory
ax.plot(predicted_x_positions, predicted_y_positions, label='Predicted Trajectory', marker='x', linestyle='-', color='red')

# Highlighting the goal area
goal_x = [11, 14]
goal_y = [-3.65, 3.65]
ax.fill_between(goal_x, goal_y[0], goal_y[1], color='green', alpha=0.3, label='Goal Area')

# Adding labels and legend
ax.set_xlabel('X Position')
ax.set_ylabel('Y Position')
ax.set_title('Projectile Trajectory and Goal Area')
ax.legend()

# Show the plot
plt.show()