# -*- coding: utf-8 -*-
"""InitialModel_YDimensions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fVEp6NR42fGEcK3Shx1O6IYdMl7AGlza
"""

import numpy as np
import json
from keras.models import Sequential
from keras.layers import LSTM, Dense
from keras.regularizers import l2
import os

# Navigate to your folder
data_directory = '/content/drive/MyDrive/Data_Capstone_KashafMujeeb'
file_names = ['realistic_trajectory_data-3.json', 'realistic_trajectory_data-4.json', 'realistic_trajectory_data-5.json', 'realistic_trajectory_data-6.json', 'realistic_trajectory_data-7.json', 'realistic_trajectory_data-8.json', 'realistic_trajectory_data-9.json', 'realistic_trajectory_data-10.json', 'realistic_trajectory_data-11.json', 'realistic_trajectory_data-12.json', 'realistic_trajectory_data-13.json', 'realistic_trajectory_data-14.json', 'realistic_trajectory_data-15.json', 'realistic_trajectory_data-16.json', ]  # Add all your file names here


# Initialize lists to store combined data
trajectories = []
initial_accs = []
in_goal = []

# Load and combine data from all files
for file_name in file_names:
    file_path = os.path.join(data_directory, file_name)
    with open(file_path, 'r') as file:
        data = json.load(file)
        trajectories.extend([[point['y']] for point in data])
        initial_accs.extend([[point['ay']] for point in data])
        in_goal.extend([1 if point['in_goal'] else 0 for point in data])

# Parameters
num_timesteps = 13  # Number of timesteps per sequence

# Prepare the training data
X_train_pos = []
X_train_acc = []
y_train = []
y_train_goal = []

for i in range(len(trajectories) - num_timesteps):
    X_train_pos.append(trajectories[i:i+num_timesteps])
    X_train_acc.append(initial_accs[i])
    y_train.append(trajectories[i + num_timesteps])
    y_train_goal.append(in_goal[i + num_timesteps])

X_train_pos = np.array(X_train_pos)
X_train_acc = np.array(X_train_acc)
y_train = np.array(y_train)
y_train_goal = np.array(y_train_goal)

from keras.layers import Dense, LSTM, Dropout, Input, Concatenate, Reshape
from keras.models import Model
from keras.regularizers import l2

# Define the LSTM model
input_pos = Input(shape=(num_timesteps, 1))  # Only 1 feature per timestep (x position)
input_acc = Input(shape=(1,))  # Only 1 feature for acceleration (ax), reshaped later

# LSTM layers for trajectory
x = LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01))(input_pos)
x = Dropout(0.2)(x)
x = LSTM(128, return_sequences=True, kernel_regularizer=l2(0.01))(x)
x = Dropout(0.2)(x)
x = LSTM(64, kernel_regularizer=l2(0.01))(x)

# Reshape acceleration input to match the dimensions needed for Concatenate
reshaped_acc = Reshape((1,))(input_acc)
combined = Concatenate(axis=-1)([x, reshaped_acc])

# Output layers
output_pos = Dense(1, activation='linear', name='position')(combined)  # Predicts x position
output_goal = Dense(1, activation='sigmoid', name='goal')(combined)  # Predicts goal status

model = Model(inputs=[input_pos, input_acc], outputs=[output_pos, output_goal])

# Compile the model
model.compile(optimizer='adam', loss={'position': 'mean_squared_error', 'goal': 'binary_crossentropy'},
              loss_weights={'position': 1.0, 'goal': 0.1})

# Train the model
model.fit([X_train_pos, X_train_acc], [y_train, y_train_goal], epochs=200, batch_size=64, validation_split=0.2)

# Save the model
model.save('y_position_goal_model.keras')

import numpy as np
from keras.models import load_model

# Load the previously saved model
model = load_model('/content/sample_data/y_position_goal_model.keras')

# Function to generate predictions recursively
def generate_predictions(initial_position, initial_acceleration, num_timesteps, num_predictions):
    # Start with the initial position repeated to fill the time steps
    current_position = np.full((num_timesteps, 1), initial_position)  # Shape (num_timesteps, 1)
    initial_acceleration = np.array([initial_acceleration])  # Shape (1,)

    predictions = []

    for _ in range(num_predictions):
        # Prepare inputs for prediction
        input_position = current_position.reshape(1, num_timesteps, 1)  # Reshape for LSTM input
        input_acceleration = initial_acceleration.reshape(1, 1)  # Reshape for LSTM input

        # Predict the next position
        predicted_position = model.predict([input_position, input_acceleration])

        # Check the type of predicted_position and ensure it's an np.array
        if isinstance(predicted_position, list):
            predicted_position = np.array(predicted_position[0])  # Assuming the list contains one array
        else:
            predicted_position = np.array(predicted_position)

        # Append the predicted position to the output
        predictions.append(predicted_position.flatten().tolist())

        # Update the current position sequence
        current_position = np.vstack((current_position[1:], predicted_position))

    return predictions

# Example usage:
initial_position = 0.06491089799162905 # Starting x position
initial_acceleration = 3.200573950646076  # Starting ax value, assuming constant acceleration
num_timesteps = 13
num_predictions = 10

# Generate predictions
predicted_positions = generate_predictions(initial_position, initial_acceleration, num_timesteps, num_predictions)

# Print the predicted positions
for i, position in enumerate(predicted_positions, 1):
    print(f"Predicted position {i}: y = {position}")